(window.webpackJsonp=window.webpackJsonp||[]).push([[511],{3591:function(v,a,_){"use strict";_.r(a);var t=_(7),r=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"在我们打开-class-字节码文件的时候-发现使用-utf-8-编码格式打开是乱码-使用二进制编码格式打开-不是乱码。-二进制编码与utf-8-编码有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在我们打开-class-字节码文件的时候-发现使用-utf-8-编码格式打开是乱码-使用二进制编码格式打开-不是乱码。-二进制编码与utf-8-编码有什么区别"}},[v._v("#")]),v._v(" 在我们打开.class 字节码文件的时候，发现使用 utf-8 编码格式打开是乱码，使用二进制编码格式打开 不是乱码。 二进制编码与utf-8 编码有什么区别？")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("二进制编码是一种计算机可以理解的编码方式，其能够直接将字节转换为二进制位，而不需要通过特定的字符集对其进行解释。因此，使用二进制方式打开 .class 文件能够直接查看其中的二进制数据，不会产生乱码。")])]),v._v(" "),a("li",[a("p",[v._v("UTF-8 是一种面向Unicode的字符编码方式，它能够用来描述世界上所有语言的符号。UTF-8 编码能够将 Unicode 字符以不同长度的字节序列进行编码，使得在不同语言之间进行文本交换变得更加容易。但是，如果一个文件采用了非 UTF-8 编码格式，使用 UTF-8 方式打开就可能产生乱码。")])])]),v._v(" "),a("p",[v._v("因此使用 utf-8 打开字节码文件会出现乱码")]),v._v(" "),a("p",[v._v("todo : 1、手写解析.class文件工具")]),v._v(" "),a("h2",{attrs:{id:"什么是方法句柄"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是方法句柄"}},[v._v("#")]),v._v(" 什么是方法句柄")]),v._v(" "),a("p",[v._v("方法句柄是一种轻量且高效的方式来操作方法和字段，它提供了一种在字节码层面上进行动态方法调用和字段访问的机制。")]),v._v(" "),a("p",[v._v("方法句柄（Method Handle）是 Java 7 引入的一种新的引用类型，用于在字节码层面上直接操作方法。它是一个有固定类型的引用，可以指向任意方法、构造函数或字段。")]),v._v(" "),a("p",[v._v("方法句柄提供了一种通用的机制来处理方法调用和字段访问，类似于 Java 中的反射机制。但与传统的反射 API 相比，方法句柄更轻量级且执行效率更高。它是通过 "),a("code",[v._v("java.lang.invoke")]),v._v(" 包中的 "),a("code",[v._v("MethodHandle")]),v._v(" 类来表示的。")]),v._v(" "),a("p",[v._v("方法句柄包含以下信息：")]),v._v(" "),a("ul",[a("li",[v._v("类型：方法句柄具有固定的方法类型，包括参数类型和返回类型。")]),v._v(" "),a("li",[v._v("引用：指向具体方法、构造函数或字段的引用。")]),v._v(" "),a("li",[v._v("访问权限：方法句柄可能需要对目标方法或字段的访问权限。")])]),v._v(" "),a("p",[v._v("通过方法句柄，我们可以动态地调用方法、获取或修改字段的值。在字节码层面，使用方法句柄比传统的方法调用更高效，因为它能够避免不必要的方法解析和动态分派操作。")]),v._v(" "),a("p",[v._v("常见的使用场景包括：")]),v._v(" "),a("ul",[a("li",[v._v("函数式编程：可以将方法句柄视为函数的引用，进行函数式编程操作。")]),v._v(" "),a("li",[v._v("Lambda 表达式：Lambda 表达式可以通过方法句柄来实现函数接口的实例化。")]),v._v(" "),a("li",[v._v("动态代理：方法句柄可用于实现动态代理，处理代理对象的方法调用。")]),v._v(" "),a("li",[v._v("方法调用转换：可以通过方法句柄来转换不同方法调用的参数类型或返回类型。")])]),v._v(" "),a("h2",{attrs:{id:"栈内存oom-与-stack-over-flow-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈内存oom-与-stack-over-flow-有什么区别"}},[v._v("#")]),v._v(" 栈内存OOM 与 stack over flow 有什么区别？")]),v._v(" "),a("p",[v._v("Java 虚拟机规范允许 "),a("strong",[v._v("Java虚拟机栈的大小是动态的或者是固定不变的")])]),v._v(" "),a("ul",[a("li",[v._v("如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 "),a("strong",[v._v("StackOverflowError")]),v._v(" 异常")]),v._v(" "),a("li",[v._v("如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个"),a("strong",[v._v("OutOfMemoryError")]),v._v("异常")])]),v._v(" "),a("p",[v._v("虚拟机栈溢出是发生在单个线程的虚拟机栈中，而OutOfMemoryError则表示整个虚拟机无法创建更多的线程了。两者的异常信息和原因也是不同的。")]),v._v(" "),a("h2",{attrs:{id:"jvm中-虚拟机栈-与栈帧有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm中-虚拟机栈-与栈帧有什么区别"}},[v._v("#")]),v._v(" jvm中 虚拟机栈 与栈帧有什么区别？")]),v._v(" "),a("p",[v._v("虚拟机栈 是由一个个 栈帧组成的。当创建了一个新的java线程的时候，就会为此程序分配一个 虚拟机栈内存，当此程序执行一个方法的时候，就会在次栈内存上进行一个栈帧入栈的操作。方法执行完成后，就会伴随着栈帧出栈的操作。")]),v._v(" "),a("p",[v._v("栈帧 是由 局部变量表、操作数栈、动态链接 、返回值地址、一些附加信息等元素组成。")])])}),[],!1,null,null,null);a.default=r.exports}}]);