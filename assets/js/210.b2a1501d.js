(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{3520:function(s,n,a){"use strict";a.r(n);var e=a(7),t=Object(e.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"map-hashset-hashmap-源码解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map-hashset-hashmap-源码解析"}},[s._v("#")]),s._v(" Map - HashSet & HashMap 源码解析")]),s._v(" "),n("p",[s._v("===========================================================")]),s._v(" "),n("blockquote",[n("p",[s._v("本文主要对Map - HashSet & HashMap进行源码解析。@pdai")])]),s._v(" "),n("h2",{attrs:{id:"java7-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java7-hashmap"}},[s._v("#")]),s._v(" Java7 HashMap")]),s._v(" "),n("h3",{attrs:{id:"概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[s._v("#")]),s._v(" 概述")]),s._v(" "),n("p",[s._v("之所以把"),n("em",[s._v("HashSet")]),s._v("和"),n("em",[s._v("HashMap")]),s._v("放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说"),n("em",[s._v("HashSet")]),s._v("里面有一个"),n("em",[s._v("HashMap")]),s._v("(适配器模式)。因此本文将重点分析"),n("em",[s._v("HashMap")]),s._v("。")]),s._v(" "),n("p",[n("em",[s._v("HashMap")]),s._v("实现了"),n("em",[s._v("Map")]),s._v("接口，即允许放入"),n("code",[s._v("key")]),s._v("为"),n("code",[s._v("null")]),s._v("的元素，也允许插入"),n("code",[s._v("value")]),s._v("为"),n("code",[s._v("null")]),s._v("的元素；除该类未实现同步外，其余跟"),n("code",[s._v("Hashtable")]),s._v("大致相同；跟"),n("em",[s._v("TreeMap")]),s._v("不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个"),n("em",[s._v("HashMap")]),s._v("的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。"),n("strong",[s._v("Java7 "),n("em",[s._v("HashMap")]),s._v("采用的是冲突链表方式")]),s._v("。")]),s._v(" "),n("p",[n("img",{attrs:{src:a(414),alt:"HashMap_base"}})]),s._v(" "),n("p",[s._v("从上图容易看出，如果选择合适的哈希函数，"),n("code",[s._v("put()")]),s._v("和"),n("code",[s._v("get()")]),s._v("方法可以在常数时间内完成。但在对"),n("em",[s._v("HashMap")]),s._v("进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将"),n("em",[s._v("HashMap")]),s._v("的初始大小设的过大。")]),s._v(" "),n("p",[s._v("有两个参数可以影响"),n("em",[s._v("HashMap")]),s._v("的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始"),n("code",[s._v("table")]),s._v("的大小，负载系数用来指定自动扩容的临界值。当"),n("code",[s._v("entry")]),s._v("的数量超过"),n("code",[s._v("capacity*load_factor")]),s._v("时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。")]),s._v(" "),n("p",[s._v("将对象放入到"),n("em",[s._v("HashMap")]),s._v("或"),n("em",[s._v("HashSet")]),s._v("中时，有两个方法需要特别关心: "),n("code",[s._v("hashCode()")]),s._v("和"),n("code",[s._v("equals()")]),s._v("。"),n("strong",[n("code",[s._v("hashCode()")]),s._v("方法决定了对象会被放到哪个"),n("code",[s._v("bucket")]),s._v("里，当多个对象的哈希值冲突时，"),n("code",[s._v("equals()")]),s._v("方法决定了这些对象是否是“同一个对象”")]),s._v("。所以，如果要将自定义的对象放入到"),n("code",[s._v("HashMap")]),s._v("或"),n("code",[s._v("HashSet")]),s._v("中，需要**@Override** "),n("code",[s._v("hashCode()")]),s._v("和"),n("code",[s._v("equals()")]),s._v("方法。")]),s._v(" "),n("h3",{attrs:{id:"get"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[s._v("#")]),s._v(" get()")]),s._v(" "),n("p",[n("code",[s._v("get(Object key)")]),s._v("方法根据指定的"),n("code",[s._v("key")]),s._v("值返回对应的"),n("code",[s._v("value")]),s._v("，该方法调用了"),n("code",[s._v("getEntry(Object key)")]),s._v("得到相应的"),n("code",[s._v("entry")]),s._v("，然后返回"),n("code",[s._v("entry.getValue()")]),s._v("。因此"),n("code",[s._v("getEntry()")]),s._v("是算法的核心。 算法思想是首先通过"),n("code",[s._v("hash()")]),s._v("函数得到对应"),n("code",[s._v("bucket")]),s._v("的下标，然后依次遍历冲突链表，通过"),n("code",[s._v("key.equals(k)")]),s._v("方法来判断是否是要找的那个"),n("code",[s._v("entry")]),s._v("。")]),s._v(" "),n("p",[n("img",{attrs:{src:a(415),alt:"HashMap_getEntry"}})]),s._v(" "),n("p",[s._v("上图中"),n("code",[s._v("hash(k)&(table.length-1)")]),s._v("等价于"),n("code",[s._v("hash(k)%table.length")]),s._v("，原因是"),n("em",[s._v("HashMap")]),s._v("要求"),n("code",[s._v("table.length")]),s._v("必须是2的指数，因此"),n("code",[s._v("table.length-1")]),s._v("就是二进制低位全是1，跟"),n("code",[s._v("hash(k)")]),s._v("相与会将哈希值的高位全抹掉，剩下的就是余数了。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        Object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n} \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("h3",{attrs:{id:"put"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#put"}},[s._v("#")]),s._v(" put()")]),s._v(" "),n("p",[n("code",[s._v("put(K key, V value)")]),s._v("方法是将指定的"),n("code",[s._v("key, value")]),s._v("对添加到"),n("code",[s._v("map")]),s._v("里。该方法首先会对"),n("code",[s._v("map")]),s._v("做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于"),n("code",[s._v("getEntry()")]),s._v("方法；如果没有找到，则会通过"),n("code",[s._v("addEntry(int hash, K key, V value, int bucketIndex)")]),s._v("方法插入新的"),n("code",[s._v("entry")]),s._v("，插入方式为"),n("strong",[s._v("头插法")]),s._v("。")]),s._v(" "),n("p",[n("img",{attrs:{src:a(416),alt:"HashMap_addEntry"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n} \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("h3",{attrs:{id:"remove"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remove"}},[s._v("#")]),s._v(" remove()")]),s._v(" "),n("p",[n("code",[s._v("remove(Object key)")]),s._v("的作用是删除"),n("code",[s._v("key")]),s._v("值对应的"),n("code",[s._v("entry")]),s._v("，该方法的具体逻辑是在"),n("code",[s._v("removeEntryForKey(Object key)")]),s._v("里实现的。"),n("code",[s._v("removeEntryForKey()")]),s._v("方法会首先找到"),n("code",[s._v("key")]),s._v("值对应的"),n("code",[s._v("entry")]),s._v("，然后删除该"),n("code",[s._v("entry")]),s._v("(修改链表的相应引用)。查找过程跟"),n("code",[s._v("getEntry()")]),s._v("过程类似。")]),s._v(" "),n("p",[n("img",{attrs:{src:a(417),alt:"HashMap_removeEntryForKey"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//removeEntryForKey()\nfinal Entry<K,V> removeEntryForKey(Object key) {\n\t......\n\tint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);//hash&(table.length-1)\n    Entry<K,V> prev = table[i];//得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {//遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modCount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n} \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])]),n("h2",{attrs:{id:"java8-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java8-hashmap"}},[s._v("#")]),s._v(" Java8 HashMap")]),s._v(" "),n("hr"),s._v(" "),n("p",[s._v("Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 "),n("strong",[s._v("数组+链表+红黑树")]),s._v(" 组成。")]),s._v(" "),n("p",[s._v("根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。")]),s._v(" "),n("p",[s._v("为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。")]),s._v(" "),n("p",[s._v("来一张图简单示意一下吧：")]),s._v(" "),n("p",[n("img",{attrs:{src:a(418),alt:""}})]),s._v(" "),n("p",[s._v("注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。")]),s._v(" "),n("p",[s._v("下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。")]),s._v(" "),n("p",[s._v("Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。")]),s._v(" "),n("p",[s._v("我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。")]),s._v(" "),n("h3",{attrs:{id:"put-过程分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#put-过程分析"}},[s._v("#")]),s._v(" put 过程分析")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n// 第五个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n\n    else {// 数组该位置有数据\n        Node<K,V> e; K k;\n        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 到这里，说明数组该位置上是一个链表\n            for (int binCount = 0; ; ++binCount) {\n                // 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个\n                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 如果在该链表中找到了"相等"的 key(== 或 equals)\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node\n                    break;\n                p = e;\n            }\n        }\n        // e!=null 说明存在旧值的key与要插入的key"相等"\n        // 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n} \n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br"),n("span",{staticClass:"line-number"},[s._v("62")]),n("br"),n("span",{staticClass:"line-number"},[s._v("63")]),n("br")])]),n("p",[s._v("和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。")]),s._v(" "),n("h3",{attrs:{id:"数组扩容"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组扩容"}},[s._v("#")]),s._v(" 数组扩容")]),s._v(" "),n("p",[s._v("resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("final Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) { // 对应数组扩容\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 将数组大小扩大一倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // 将阈值扩大一倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候\n        newCap = oldThr;\n    else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n\n    // 用新的数组大小初始化新的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可\n\n    if (oldTab != null) {\n        // 开始遍历原数组，进行数据迁移。\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果是红黑树，具体我们就不展开了\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    // 这块是处理链表的情况，\n                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        // 第一条链表\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        // 第二条链表的新的位置是 j + oldCap，这个很好理解\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n} \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br"),n("span",{staticClass:"line-number"},[s._v("62")]),n("br"),n("span",{staticClass:"line-number"},[s._v("63")]),n("br"),n("span",{staticClass:"line-number"},[s._v("64")]),n("br"),n("span",{staticClass:"line-number"},[s._v("65")]),n("br"),n("span",{staticClass:"line-number"},[s._v("66")]),n("br"),n("span",{staticClass:"line-number"},[s._v("67")]),n("br"),n("span",{staticClass:"line-number"},[s._v("68")]),n("br"),n("span",{staticClass:"line-number"},[s._v("69")]),n("br"),n("span",{staticClass:"line-number"},[s._v("70")]),n("br"),n("span",{staticClass:"line-number"},[s._v("71")]),n("br"),n("span",{staticClass:"line-number"},[s._v("72")]),n("br"),n("span",{staticClass:"line-number"},[s._v("73")]),n("br"),n("span",{staticClass:"line-number"},[s._v("74")]),n("br"),n("span",{staticClass:"line-number"},[s._v("75")]),n("br"),n("span",{staticClass:"line-number"},[s._v("76")]),n("br"),n("span",{staticClass:"line-number"},[s._v("77")]),n("br"),n("span",{staticClass:"line-number"},[s._v("78")]),n("br"),n("span",{staticClass:"line-number"},[s._v("79")]),n("br"),n("span",{staticClass:"line-number"},[s._v("80")]),n("br"),n("span",{staticClass:"line-number"},[s._v("81")]),n("br"),n("span",{staticClass:"line-number"},[s._v("82")]),n("br"),n("span",{staticClass:"line-number"},[s._v("83")]),n("br"),n("span",{staticClass:"line-number"},[s._v("84")]),n("br"),n("span",{staticClass:"line-number"},[s._v("85")]),n("br"),n("span",{staticClass:"line-number"},[s._v("86")]),n("br")])]),n("h3",{attrs:{id:"get-过程分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#get-过程分析"}},[s._v("#")]),s._v(" get 过程分析")]),s._v(" "),n("p",[s._v("相对于 put 来说，get 真的太简单了。")]),s._v(" "),n("ul",[n("li",[s._v("计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash & (length-1)")]),s._v(" "),n("li",[s._v("判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步")]),s._v(" "),n("li",[s._v("判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步")]),s._v(" "),n("li",[s._v("遍历链表，直到找到相等(==或equals)的 key")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 判断第一个节点是不是就是需要的\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断是否是红黑树\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\n            // 链表遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n} \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])]),n("h2",{attrs:{id:"hashset"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[s._v("#")]),s._v(" HashSet")]),s._v(" "),n("hr"),s._v(" "),n("p",[s._v("前面已经说过"),n("em",[s._v("HashSet")]),s._v("是对"),n("em",[s._v("HashMap")]),s._v("的简单包装，对"),n("em",[s._v("HashSet")]),s._v("的函数调用都会转换成合适的"),n("em",[s._v("HashMap")]),s._v("方法，因此"),n("em",[s._v("HashSet")]),s._v("的实现非常简单，只有不到300行代码。这里不再赘述。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//HashSet是对HashMap的简单包装\npublic class HashSet<E>\n{\n\t......\n\tprivate transient HashMap<E,Object> map;//HashSet里面有一个HashMap\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n    public HashSet() {\n        map = new HashMap<>();\n    }\n    ......\n    public boolean add(E e) {//简单的方法转换\n        return map.put(e, PRESENT)==null;\n    }\n    ......\n} \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])])])}),[],!1,null,null,null);n.default=t.exports},414:function(s,n,a){s.exports=a.p+"assets/img/collection_HashMap_base.b139686a.png"},415:function(s,n,a){s.exports=a.p+"assets/img/collection_HashMap_getEntry.9486eca4.png"},416:function(s,n,a){s.exports=a.p+"assets/img/collection_HashMap_addEntry.483a0218.png"},417:function(s,n,a){s.exports=a.p+"assets/img/collection_HashMap_removeEntryForKey.1a032aae.png"},418:function(s,n,a){s.exports=a.p+"assets/img/java-collection-hashmap8.6bb124cd.png"}}]);