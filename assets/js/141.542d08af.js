(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{1463:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-1.72e0b919.jpg"},1464:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-2.bc3f7bc4.jpg"},1465:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-3.699614ee.jpg"},1466:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-4.c8fc5993.jpg"},1467:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-5.c43de035.jpg"},1468:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-6.da189527.jpg"},1469:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-7.54f5d73e.jpg"},1470:function(a,n,s){a.exports=s.p+"assets/img/alg-sort-heap-8.48a941f8.jpg"},3776:function(a,n,s){"use strict";s.r(n);var t=s(7),r=Object(t.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"排序-堆排序-heap-sort"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#排序-堆排序-heap-sort"}},[a._v("#")]),a._v(" 排序 - 堆排序(Heap Sort)")]),a._v(" "),n("p",[a._v("==========================================")]),a._v(" "),n("blockquote",[n("p",[a._v("堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。@pdai")])]),a._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D",target:"_blank",rel:"noopener noreferrer"}},[a._v("堆排序介绍"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"}},[a._v("堆排序实现"),n("OutboundLink")],1),a._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86",target:"_blank",rel:"noopener noreferrer"}},[a._v("初始化堆"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE",target:"_blank",rel:"noopener noreferrer"}},[a._v("交换数据"),n("OutboundLink")],1)])])]),a._v(" "),n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%A0%86%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[a._v("堆排序复杂度和稳定性"),n("OutboundLink")],1),a._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6",target:"_blank",rel:"noopener noreferrer"}},[a._v("堆排序时间复杂度"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[a._v("堆排序稳定性"),n("OutboundLink")],1)])])]),a._v(" "),n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"}},[a._v("代码实现"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-sort-x-heap.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考文章"),n("OutboundLink")],1)])]),a._v(" "),n("h1",{attrs:{id:"堆排序介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆排序介绍"}},[a._v("#")]),a._v(" 堆排序介绍")]),a._v(" "),n("hr"),a._v(" "),n("p",[a._v("学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先了解堆(建议可以通过二叉堆，左倾堆，斜堆，二项堆或斐波那契堆等文章进行了解)，然后再来学习本章。")]),a._v(" "),n("p",[a._v('我们知道，堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。')]),a._v(" "),n("p",[a._v("最大堆进行升序排序的基本思想: ① 初始化堆: 将数列a[1...n]构造成最大堆。 ② 交换数据: 将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。")]),a._v(" "),n("p",[a._v('下面，通过图文来解析堆排序的实现过程。注意实现中用到了"数组实现的二叉堆的性质"。 在第一个元素的索引为 0 的情形中:')]),a._v(" "),n("ul",[n("li",[a._v("性质一: 索引为i的左孩子的索引是 (2*i+1);")]),a._v(" "),n("li",[a._v("性质二: 索引为i的右孩子的索引是 (2*i+2);")]),a._v(" "),n("li",[a._v("性质三: 索引为i的父结点的索引是 floor((i-1)/2);")])]),a._v(" "),n("p",[n("img",{attrs:{src:s(1463),alt:""}})]),a._v(" "),n("p",[a._v("例如，对于最大堆{110,100,90,40,80,20,60,10,30,50,70}而言: 索引为0的左孩子的所有是1；索引为0的右孩子是2；索引为8的父节点是3。")]),a._v(" "),n("h1",{attrs:{id:"堆排序实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆排序实现"}},[a._v("#")]),a._v(" 堆排序实现")]),a._v(" "),n("hr"),a._v(" "),n("p",[a._v("下面演示heap_sort_asc(a, n)对a={20,30,90,40,70,110,60,10,100,50,80}, n=11进行堆排序过程。下面是数组a对应的初始化结构:")]),a._v(" "),n("p",[n("img",{attrs:{src:s(1464),alt:""}})]),a._v(" "),n("h3",{attrs:{id:"初始化堆"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化堆"}},[a._v("#")]),a._v(" 初始化堆")]),a._v(" "),n("p",[a._v("在堆排序算法中，首先要将待排序的数组转化成二叉堆。 下面演示将数组{20,30,90,40,70,110,60,10,100,50,80}转换为最大堆{110,100,90,40,80,20,60,10,30,50,70}的步骤。")]),a._v(" "),n("ul",[n("li",[a._v("1.1 i=11/2-1，即i=4")])]),a._v(" "),n("p",[n("img",{attrs:{src:s(1465),alt:""}})]),a._v(" "),n("p",[a._v("上面是maxheap_down(a, 4, 9)调整过程。maxheap_down(a, 4, 9)的作用是将a[4...9]进行下调；a[4]的左孩子是a[9]，右孩子是a[10]。调整时，选择左右孩子中较大的一个(即a[10])和a[4]交换。")]),a._v(" "),n("ul",[n("li",[a._v("1.2 i=3")])]),a._v(" "),n("p",[n("img",{attrs:{src:s(1466),alt:""}})]),a._v(" "),n("p",[a._v("上面是maxheap_down(a, 3, 9)调整过程。maxheap_down(a, 3, 9)的作用是将a[3...9]进行下调；a[3]的左孩子是a[7]，右孩子是a[8]。调整时，选择左右孩子中较大的一个(即a[8])和a[4]交换。")]),a._v(" "),n("ul",[n("li",[a._v("1.3 i=2")])]),a._v(" "),n("p",[n("img",{attrs:{src:s(1467),alt:""}})]),a._v(" "),n("p",[a._v("上面是maxheap_down(a, 2, 9)调整过程。maxheap_down(a, 2, 9)的作用是将a[2...9]进行下调；a[2]的左孩子是a[5]，右孩子是a[6]。调整时，选择左右孩子中较大的一个(即a[5])和a[2]交换。")]),a._v(" "),n("ul",[n("li",[a._v("1.4 i=1")])]),a._v(" "),n("p",[n("img",{attrs:{src:s(1468),alt:""}})]),a._v(" "),n("p",[a._v("上面是maxheap_down(a, 1, 9)调整过程。maxheap_down(a, 1, 9)的作用是将a[1...9]进行下调；a[1]的左孩子是a[3]，右孩子是a[4]。调整时，选择左右孩子中较大的一个(即a[3])和a[1]交换。交换之后，a[3]为30，它比它的右孩子a[8]要大，接着，再将它们交换。")]),a._v(" "),n("ul",[n("li",[a._v("1.5 i=0")])]),a._v(" "),n("p",[n("img",{attrs:{src:s(1469),alt:""}})]),a._v(" "),n("p",[a._v("上面是maxheap_down(a, 0, 9)调整过程。maxheap_down(a, 0, 9)的作用是将a[0...9]进行下调；a[0]的左孩子是a[1]，右孩子是a[2]。调整时，选择左右孩子中较大的一个(即a[2])和a[0]交换。交换之后，a[2]为20，它比它的左右孩子要大，选择较大的孩子(即左孩子)和a[2]交换。")]),a._v(" "),n("p",[a._v("调整完毕，就得到了最大堆。此时，数组{20,30,90,40,70,110,60,10,100,50,80}也就变成了{110,100,90,40,80,20,60,10,30,50,70}。")]),a._v(" "),n("h3",{attrs:{id:"交换数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#交换数据"}},[a._v("#")]),a._v(" 交换数据")]),a._v(" "),n("p",[a._v("在将数组转换成最大堆之后，接着要进行交换数据，从而使数组成为一个真正的有序数组。 交换数据部分相对比较简单，下面仅仅给出将最大值放在数组末尾的示意图。")]),a._v(" "),n("p",[n("img",{attrs:{src:s(1470),alt:""}})]),a._v(" "),n("p",[a._v("上面是当n=10时，交换数据的示意图。 当n=10时，首先交换a[0]和a[10]，使得a[10]是a[0...10]之间的最大值；然后，调整a[0...9]使它称为最大堆。交换之后: a[10]是有序的！ 当n=9时， 首先交换a[0]和a[9]，使得a[9]是a[0...9]之间的最大值；然后，调整a[0...8]使它称为最大堆。交换之后: a[9...10]是有序的！ ... 依此类推，直到a[0...10]是有序的。")]),a._v(" "),n("h1",{attrs:{id:"堆排序复杂度和稳定性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆排序复杂度和稳定性"}},[a._v("#")]),a._v(" 堆排序复杂度和稳定性")]),a._v(" "),n("hr"),a._v(" "),n("h3",{attrs:{id:"堆排序时间复杂度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆排序时间复杂度"}},[a._v("#")]),a._v(" 堆排序时间复杂度")]),a._v(" "),n("p",[a._v("堆排序的时间复杂度是O(N*lgN)。")]),a._v(" "),n("p",[a._v("假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? 堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢? 由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。")]),a._v(" "),n("h3",{attrs:{id:"堆排序稳定性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆排序稳定性"}},[a._v("#")]),a._v(" 堆排序稳定性")]),a._v(" "),n("p",[a._v("堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。")]),a._v(" "),n("p",[n("code",[a._v("算法稳定性")]),a._v(" -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！")]),a._v(" "),n("h1",{attrs:{id:"代码实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[a._v("#")]),a._v(" 代码实现")]),a._v(" "),n("hr"),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('/**\n * 堆排序: Java\n *\n * @author skywang\n * @date 2014/03/11\n */\n\npublic class HeapSort {\n\n    /* \n     * (最大)堆的向下调整算法\n     *\n     * 注: 数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。\n     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)\n     *     end   -- 截至范围(一般为数组中最后一个元素的索引)\n     */\n    public static void maxHeapDown(int[] a, int start, int end) {\n        int c = start;            // 当前(current)节点的位置\n        int l = 2*c + 1;        // 左(left)孩子的位置\n        int tmp = a[c];            // 当前(current)节点的大小\n\n        for (; l <= end; c=l,l=2*l+1) {\n            // "l"是左孩子，"l+1"是右孩子\n            if ( l < end && a[l] < a[l+1])\n                l++;        // 左右两孩子中选择较大者，即m_heap[l+1]\n            if (tmp >= a[l])\n                break;        // 调整结束\n            else {            // 交换值\n                a[c] = a[l];\n                a[l]= tmp;\n            }\n        }\n    }\n\n    /*\n     * 堆排序(从小到大)\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     n -- 数组的长度\n     */\n    public static void heapSortAsc(int[] a, int n) {\n        int i,tmp;\n\n        // 从(n/2-1) --\x3e 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。\n        for (i = n / 2 - 1; i >= 0; i--)\n            maxHeapDown(a, i, n-1);\n\n        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素\n        for (i = n - 1; i > 0; i--) {\n            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。\n            tmp = a[0];\n            a[0] = a[i];\n            a[i] = tmp;\n            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。\n            // 即，保证a[i-1]是a[0...i-1]中的最大值。\n            maxHeapDown(a, 0, i-1);\n        }\n    }\n\n    /* \n     * (最小)堆的向下调整算法\n     *\n     * 注: 数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。\n     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)\n     *     end   -- 截至范围(一般为数组中最后一个元素的索引)\n     */\n    public static void minHeapDown(int[] a, int start, int end) {\n        int c = start;            // 当前(current)节点的位置\n        int l = 2*c + 1;        // 左(left)孩子的位置\n        int tmp = a[c];            // 当前(current)节点的大小\n\n        for (; l <= end; c=l,l=2*l+1) {\n            // "l"是左孩子，"l+1"是右孩子\n            if ( l < end && a[l] > a[l+1])\n                l++;        // 左右两孩子中选择较小者\n            if (tmp <= a[l])\n                break;        // 调整结束\n            else {            // 交换值\n                a[c] = a[l];\n                a[l]= tmp;\n            }\n        }\n    }\n\n    /*\n     * 堆排序(从大到小)\n     *\n     * 参数说明: \n     *     a -- 待排序的数组\n     *     n -- 数组的长度\n     */\n    public static void heapSortDesc(int[] a, int n) {\n        int i,tmp;\n\n        // 从(n/2-1) --\x3e 0逐次遍历每。遍历之后，得到的数组实际上是一个最小堆。\n        for (i = n / 2 - 1; i >= 0; i--)\n            minHeapDown(a, i, n-1);\n\n        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素\n        for (i = n - 1; i > 0; i--) {\n            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。\n            tmp = a[0];\n            a[0] = a[i];\n            a[i] = tmp;\n            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。\n            // 即，保证a[i-1]是a[0...i-1]中的最小值。\n            minHeapDown(a, 0, i-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        int i;\n        int a[] = {20,30,90,40,70,110,60,10,100,50,80};\n\n        System.out.printf("before sort:");\n        for (i=0; i<a.length; i++)\n            System.out.printf("%d ", a[i]);\n        System.out.printf("\\n");\n\n        heapSortAsc(a, a.length);            // 升序排列\n        //heapSortDesc(a, a.length);        // 降序排列\n\n        System.out.printf("after  sort:");\n        for (i=0; i<a.length; i++)\n            System.out.printf("%d ", a[i]);\n        System.out.printf("\\n");\n    }\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br"),n("span",{staticClass:"line-number"},[a._v("33")]),n("br"),n("span",{staticClass:"line-number"},[a._v("34")]),n("br"),n("span",{staticClass:"line-number"},[a._v("35")]),n("br"),n("span",{staticClass:"line-number"},[a._v("36")]),n("br"),n("span",{staticClass:"line-number"},[a._v("37")]),n("br"),n("span",{staticClass:"line-number"},[a._v("38")]),n("br"),n("span",{staticClass:"line-number"},[a._v("39")]),n("br"),n("span",{staticClass:"line-number"},[a._v("40")]),n("br"),n("span",{staticClass:"line-number"},[a._v("41")]),n("br"),n("span",{staticClass:"line-number"},[a._v("42")]),n("br"),n("span",{staticClass:"line-number"},[a._v("43")]),n("br"),n("span",{staticClass:"line-number"},[a._v("44")]),n("br"),n("span",{staticClass:"line-number"},[a._v("45")]),n("br"),n("span",{staticClass:"line-number"},[a._v("46")]),n("br"),n("span",{staticClass:"line-number"},[a._v("47")]),n("br"),n("span",{staticClass:"line-number"},[a._v("48")]),n("br"),n("span",{staticClass:"line-number"},[a._v("49")]),n("br"),n("span",{staticClass:"line-number"},[a._v("50")]),n("br"),n("span",{staticClass:"line-number"},[a._v("51")]),n("br"),n("span",{staticClass:"line-number"},[a._v("52")]),n("br"),n("span",{staticClass:"line-number"},[a._v("53")]),n("br"),n("span",{staticClass:"line-number"},[a._v("54")]),n("br"),n("span",{staticClass:"line-number"},[a._v("55")]),n("br"),n("span",{staticClass:"line-number"},[a._v("56")]),n("br"),n("span",{staticClass:"line-number"},[a._v("57")]),n("br"),n("span",{staticClass:"line-number"},[a._v("58")]),n("br"),n("span",{staticClass:"line-number"},[a._v("59")]),n("br"),n("span",{staticClass:"line-number"},[a._v("60")]),n("br"),n("span",{staticClass:"line-number"},[a._v("61")]),n("br"),n("span",{staticClass:"line-number"},[a._v("62")]),n("br"),n("span",{staticClass:"line-number"},[a._v("63")]),n("br"),n("span",{staticClass:"line-number"},[a._v("64")]),n("br"),n("span",{staticClass:"line-number"},[a._v("65")]),n("br"),n("span",{staticClass:"line-number"},[a._v("66")]),n("br"),n("span",{staticClass:"line-number"},[a._v("67")]),n("br"),n("span",{staticClass:"line-number"},[a._v("68")]),n("br"),n("span",{staticClass:"line-number"},[a._v("69")]),n("br"),n("span",{staticClass:"line-number"},[a._v("70")]),n("br"),n("span",{staticClass:"line-number"},[a._v("71")]),n("br"),n("span",{staticClass:"line-number"},[a._v("72")]),n("br"),n("span",{staticClass:"line-number"},[a._v("73")]),n("br"),n("span",{staticClass:"line-number"},[a._v("74")]),n("br"),n("span",{staticClass:"line-number"},[a._v("75")]),n("br"),n("span",{staticClass:"line-number"},[a._v("76")]),n("br"),n("span",{staticClass:"line-number"},[a._v("77")]),n("br"),n("span",{staticClass:"line-number"},[a._v("78")]),n("br"),n("span",{staticClass:"line-number"},[a._v("79")]),n("br"),n("span",{staticClass:"line-number"},[a._v("80")]),n("br"),n("span",{staticClass:"line-number"},[a._v("81")]),n("br"),n("span",{staticClass:"line-number"},[a._v("82")]),n("br"),n("span",{staticClass:"line-number"},[a._v("83")]),n("br"),n("span",{staticClass:"line-number"},[a._v("84")]),n("br"),n("span",{staticClass:"line-number"},[a._v("85")]),n("br"),n("span",{staticClass:"line-number"},[a._v("86")]),n("br"),n("span",{staticClass:"line-number"},[a._v("87")]),n("br"),n("span",{staticClass:"line-number"},[a._v("88")]),n("br"),n("span",{staticClass:"line-number"},[a._v("89")]),n("br"),n("span",{staticClass:"line-number"},[a._v("90")]),n("br"),n("span",{staticClass:"line-number"},[a._v("91")]),n("br"),n("span",{staticClass:"line-number"},[a._v("92")]),n("br"),n("span",{staticClass:"line-number"},[a._v("93")]),n("br"),n("span",{staticClass:"line-number"},[a._v("94")]),n("br"),n("span",{staticClass:"line-number"},[a._v("95")]),n("br"),n("span",{staticClass:"line-number"},[a._v("96")]),n("br"),n("span",{staticClass:"line-number"},[a._v("97")]),n("br"),n("span",{staticClass:"line-number"},[a._v("98")]),n("br"),n("span",{staticClass:"line-number"},[a._v("99")]),n("br"),n("span",{staticClass:"line-number"},[a._v("100")]),n("br"),n("span",{staticClass:"line-number"},[a._v("101")]),n("br"),n("span",{staticClass:"line-number"},[a._v("102")]),n("br"),n("span",{staticClass:"line-number"},[a._v("103")]),n("br"),n("span",{staticClass:"line-number"},[a._v("104")]),n("br"),n("span",{staticClass:"line-number"},[a._v("105")]),n("br"),n("span",{staticClass:"line-number"},[a._v("106")]),n("br"),n("span",{staticClass:"line-number"},[a._v("107")]),n("br"),n("span",{staticClass:"line-number"},[a._v("108")]),n("br"),n("span",{staticClass:"line-number"},[a._v("109")]),n("br"),n("span",{staticClass:"line-number"},[a._v("110")]),n("br"),n("span",{staticClass:"line-number"},[a._v("111")]),n("br"),n("span",{staticClass:"line-number"},[a._v("112")]),n("br"),n("span",{staticClass:"line-number"},[a._v("113")]),n("br"),n("span",{staticClass:"line-number"},[a._v("114")]),n("br"),n("span",{staticClass:"line-number"},[a._v("115")]),n("br"),n("span",{staticClass:"line-number"},[a._v("116")]),n("br"),n("span",{staticClass:"line-number"},[a._v("117")]),n("br"),n("span",{staticClass:"line-number"},[a._v("118")]),n("br"),n("span",{staticClass:"line-number"},[a._v("119")]),n("br"),n("span",{staticClass:"line-number"},[a._v("120")]),n("br"),n("span",{staticClass:"line-number"},[a._v("121")]),n("br"),n("span",{staticClass:"line-number"},[a._v("122")]),n("br"),n("span",{staticClass:"line-number"},[a._v("123")]),n("br"),n("span",{staticClass:"line-number"},[a._v("124")]),n("br"),n("span",{staticClass:"line-number"},[a._v("125")]),n("br"),n("span",{staticClass:"line-number"},[a._v("126")]),n("br"),n("span",{staticClass:"line-number"},[a._v("127")]),n("br"),n("span",{staticClass:"line-number"},[a._v("128")]),n("br"),n("span",{staticClass:"line-number"},[a._v("129")]),n("br"),n("span",{staticClass:"line-number"},[a._v("130")]),n("br"),n("span",{staticClass:"line-number"},[a._v("131")]),n("br"),n("span",{staticClass:"line-number"},[a._v("132")]),n("br"),n("span",{staticClass:"line-number"},[a._v("133")]),n("br"),n("span",{staticClass:"line-number"},[a._v("134")]),n("br"),n("span",{staticClass:"line-number"},[a._v("135")]),n("br"),n("span",{staticClass:"line-number"},[a._v("136")]),n("br"),n("span",{staticClass:"line-number"},[a._v("137")]),n("br")])]),n("h1",{attrs:{id:"参考文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),n("hr"),a._v(" "),n("p",[a._v("提示")]),a._v(" "),n("p",[a._v("本文主要参考至 https://www.cnblogs.com/skywang12345/p/3602162.html, 在此基础上做了内容的增改。)")])])}),[],!1,null,null,null);n.default=r.exports}}]);