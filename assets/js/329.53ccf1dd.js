(window.webpackJsonp=window.webpackJsonp||[]).push([[329],{3497:function(e,s,n){e.exports=n.p+"assets/img/Invoker实现图解.e5d8063a.png"},3498:function(e,s,n){e.exports=n.p+"assets/img/DefaultReflectorFactory关系图.b9e85805.png"},3499:function(e,s,n){e.exports=n.p+"assets/img/Type类结构图.78ba42c2.png"},4242:function(e,s,n){"use strict";n.r(s);var a=n(7),t=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("My Batis 在进行"),s("strong",[e._v("参数处理")]),e._v("、"),s("strong",[e._v("结果映射")]),e._v("等操作时 会涉及大量的反射操作。 Java 中的反射虽\n然功能强大，但是代码编写起来比较复杂且容易出错，为了简化反射操作的相关代码， MyBatis 提供了专门的反射模块，该模块位于\norg.apache.ibatis.reflection 包中，它对常见的反射操作做了进一步封装，提供了更加简洁方便的反射 API 。")]),e._v(" "),s("h2",{attrs:{id:"reflector-reflectorfactory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reflector-reflectorfactory"}},[e._v("#")]),e._v(" Reflector&ReflectorFactory")]),e._v(" "),s("p",[e._v("这里简单回顾 JavaBean 规范：类中定义的成员变 也称为“宇段”，属性则是通过 getter/setter 方法得到的，属性只与类中的方法有关，\n与是否存在对应成员变量没有关系。例如，存在 getA()方法和 setA(String）方法，无论类中是否定义了字段 Sting a，我们都认为该类中存在属性\n。在后面的分析中 ，属性的 getter/setter 方法\n与同名的字段虽然会一起出现，但还是有必要区分这两个概念。")]),e._v(" "),s("p",[e._v("Reflector是MyBatis 中反射模块的基础，每个 "),s("strong",[e._v("Reflector")]),e._v("对象都对一个类，在 Reflector中缓存了反射操作需要使用的类的元信息。\nReflector 中各个字段的含义如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public class Reflector {\n  //jdk 15中新增加的特性而对应的方法\n  private static final MethodHandle isRecordMethodHandle = getIsRecordMethodHandle();\n  //对应的 Class 类型\n  private final Class<?> type;\n  //可读属性的名称集合，可读属性就是存在相应 getter 方法的属性，初始值为空数纽\n  private final String[] readablePropertyNames;\n  //／可写属性的名称集合，可写属性就是存在相应 setter 方法的属性，初始值为空数纽\n  private final String[] writablePropertyNames;\n  //／记录了属性相应 setter 方法 key 是属性名称， value Invoker 对象，它是对 setter 方法对应\n  // Method 对象的封装，后面会详细介绍\n  private final Map<String, Invoker> setMethods = new HashMap<>();\n  //属性相应 getter 方法集合 key 是属性名称， value 也是 Invoker 对象\n  private final Map<String, Invoker> getMethods = new HashMap<>();\n  //记录了属性相应的 setter 方法的参 值类型， ke 是属性名称， value setter 方法的参数类型\n  private final Map<String, Class<?>> setTypes = new HashMap<>();\n  //记录了属性相应的 getter 方法的返回位类型， key 是属性名称， value getter 方法的返回位类型\n  private final Map<String, Class<?>> getTypes = new HashMap<>();\n  //记录了默认构造方法\n  private Constructor<?> defaultConstructor;\n  //记录了所有属性名称的 集合\n  private final Map<String, String> caseInsensitivePropertyMap = new HashMap<>();\n  .........  \n        \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br")])]),s("p",[e._v("在Reflector的构造方法中会解析指定的 Class 对象，并填充上述集合，具体实现如下:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public Reflector(Class<?> clazz) {\n    //初始化Class<?> type 字段\n    type = clazz;\n    //查找 clazz 的默认构造方法（元参构造方法）具体实现是通过反射遥历所有构造方法，代码并不复杂，\n    addDefaultConstructor(clazz);\n    //获取本类以及父类们的所有方法\n    Method[] classMethods = getClassMethods(clazz);\n    if (isRecord(type)) {\n      //java 15新出来的一种类型，后续探索一下作用\n      addRecordGetMethods(classMethods);\n    } else {\n      //处理 clazz 中的 getter 方法，填充 getMethods 集合和 getTypes 集合\n      addGetMethods(classMethods);\n      //处理 clazz 中的 setter 方法，填充 setMethods 集合和 setTypes 集合\n      addSetMethods(classMethods);\n      //处理没 getter/setter 方法的字段\n      addFields(clazz);\n    }\n\n    readablePropertyNames = getMethods.keySet().toArray(new String[0]);\n    writablePropertyNames = setMethods.keySet().toArray(new String[0]);\n    for (String propName : readablePropertyNames) {\n      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);\n    }\n    for (String propName : writablePropertyNames) {\n      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);\n    }\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br")])]),s("p",[e._v("Reflector.addGetMethods()方法主要负责解析类中定义的 getter 方法， Reflector.addSetMethods()\n方法负责解析类中定义的 setter 方法，两者的逻辑类似，这里以 addGetMethods()方法为例进行介绍， addSetMethods()\n方法不再详细介绍，请读者参考源码学习。 Reflector addGetMethods()\n法有如下三个核心步骤"),s("br"),e._v("\n(1)、首先，调用 Reflector.getClassMethods()方法获取当前类以及其父类中定义的所有方法的唯一签名 以及相应的 Method 对象")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" private Method[] getClassMethods(Class<?> clazz) {\n    //用于记录指定类中定义的全部方法的唯一签名以及对应的 Method 对象(除构造方法以外的方法)\n    Map<String, Method> uniqueMethods = new HashMap<>();\n    Class<?> currentClass = clazz;\n    while (currentClass != null && currentClass != Object.class) {\n      //记录 currentClass 这个类中定义的全部方法\n      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());\n      // we also need to look for interface methods -\n      // because the class may be abstract\n      //记录接口中定义的方法\n      Class<?>[] interfaces = currentClass.getInterfaces();\n      for (Class<?> anInterface : interfaces) {\n        addUniqueMethods(uniqueMethods, anInterface.getMethods());\n      }\n      //获取父类 ，继续 while 循环\n      currentClass = currentClass.getSuperclass();\n    }\n    Collection<Method> methods = uniqueMethods.values();\n    return methods.toArray(new Method[0]);\n  }\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])]),s("p",[e._v("在Reflector.addUniqueMethods()方法中会为每个方法生成唯 一签名，井记录到\nuniqueMethods 集合中，具体实现如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  private void addUniqueMethods(Map<String, Method> uniqueMethods, Method[] methods) {\n    for (Method currentMethod : methods) {\n      if (!currentMethod.isBridge()) {\n        ／／通过 Reflector.getSignature()方法得到的方法签名是：返回值类型＃方法名称:参数类型列表 \n        //例如Reflector.getSignature(Method）方法的唯一签名是：java.lang.String#getSignature:java.lang.reflect.Method\n        //通过 Reflector getSignature()方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识\n        //(1)、如果子类重写了父类的方法,没有改变父类的返回值类型与参数 则子类的方法会放入map中，父类的方法不会放入map中，因为他们生成的签名是相同的。\n        String signature = getSignature(currentMethod);\n        // check to see if the method is already known\n        // if it is known, then an extended class must have\n        // overridden a method\n        if (!uniqueMethods.containsKey(signature)) {\n          uniqueMethods.put(signature, currentMethod);\n        }\n      }\n    }\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("p",[e._v("(2)、然后,按照 JavaBean 的规范，从 Reflector.getClassMethods()方法返回的 Method 数组 中查找该类中定义的 getter 方法（具体哪些方法算是\ngetter 方法，后面会详细介绍），\n将其记录 conflictingGetters 合中。 conflictingGetters 集合（ HashMap<String,List<Method>>()类型） 的key 为属性名称， value\n是该属性对应的 getter 方法集合。"),s("br"),e._v("\n(3)、当子类覆盖了父类的 getter 方法且返回值发生变化时，在步骤1中就会产生两个签名不同的方法。 例如现有类A及其子类 SubA,\nA类中定义了 getNames()方法，其返回值类型是\nList<String> 而在其子类 SubA 中， 覆写了其 getNames()方法且将返回值修改成 ArrayList<String>类型，这种覆写在 Java\n语言中是合法的。最终得到 的两个方法签名分别是 java.util.List#getNames\njava.util.ArrayList#getNames,在 Reflector.addUniqueMethods()方法中会被认为是两个不同的 方法并添加到 uniqueMethods\n集合中，这显然不是我们想要的结果。"),s("br"),e._v("\n  所以，步骤 会调用 Reflector.resolveGetterConflicts （）方法对这种覆 的情况进行处理，同\n时会将处理得到的 getter 方法记 getMethods 集合，并将其返回值类型填充到 getTypes 集合\nReflector.resolveGetterConflicts()方法的具体实现如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('//解决get方法里面的冲突,处理以下几个场景的业务\n  //1、 属性名相同但返回类型不同：在这种情况下，由于返回类型不同，代码逻辑会判断出存在歧义，。在 addGetMethod 方法中，可能会根据需要进行额外的处理，比如记录冲突的方法信息或抛出异常。\n  //2、属性名相同且返回类型相同，但存在命名冲突：当属性名相同且存在命名冲突时，根据代码逻辑，将会优先选择以 "is" 开头的方法作为胜出方法。这是因为在命名规则中，以 "is" 开头的方法通常用于返回布尔类型的属性。因此，以 "is" 开头的方法具有更高的优先级。\n  //3、属性名相同且返回类型相同，但存在继承关:如果存在属性名相同、返回类型相同，但存在继承关系的情况，代码逻辑会检查返回类型的继承关系。如果一个返回类型是另一个类型的子类或实现类，则子类的方法将被选择作为胜出方法。如果返回类型没有继承关系，则存在歧义，\n  private void resolveGetterConflicts(Map<String, List<Method>> conflictingGetters) {\n    for (Entry<String, List<Method>> entry : conflictingGetters.entrySet()) {\n      Method winner = null;\n      String propName = entry.getKey();\n      boolean isAmbiguous = false;\n      for (Method candidate : entry.getValue()) {\n        if (winner == null) {\n          winner = candidate;\n          continue;\n        }\n        Class<?> winnerType = winner.getReturnType();\n        Class<?> candidateType = candidate.getReturnType();\n        if (candidateType.equals(winnerType)) {\n          //如果 candidateType 与winnerType 相同\n          if (!boolean.class.equals(candidateType)) {\n            //并且candidateType 不是boolean 类型，则 isAmbiguous = true，歧义就开始出现了\n            isAmbiguous = true;\n            break;\n          }\n          if (candidate.getName().startsWith("is")) {\n            //candidateType 是boolean类型，则 将 winner = candidate;\n            winner = candidate;\n          }\n        } else if (candidateType.isAssignableFrom(winnerType)) {\n          //如果候选(candidateType)方法的返回类型是 winner 方法返回类型的子类或实现类。 就什么也不需要做\n          // OK getter type is descendant\n        } else if (winnerType.isAssignableFrom(candidateType)) {\n          //如果 winner 方法返回类型是候选(candidateType)方法的返回类型的子类或实现类。 则将 winner = candidate;\n          winner = candidate;\n        } else {\n          isAmbiguous = true;\n          break;\n        }\n      }\n      //使属性名与getMethods 、getTypes 之间建立关系\n      addGetMethod(propName, winner, isAmbiguous);\n    }\n  }\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br")])]),s("p",[e._v("正如上面所描述的那样，在 Reflector.addGetMethod()法中完成了对 getMethods 集合和\ngetTypes 集合的填充，具体实现如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  //添加属性名 与 方法之间的关系\n  private void addGetMethod(String name, Method method, boolean isAmbiguous) {\n    //如果isAmbiguous =true 则创建一个 AmbiguousMethodInvoker 对象，否则创建一个 MethodInvoker 对象\n    MethodInvoker invoker = isAmbiguous ? new AmbiguousMethodInvoker(method, MessageFormat.format(\n        \"Illegal overloaded getter method with ambiguous type for property ''{0}'' in class ''{1}''. This breaks the JavaBeans specification and can cause unpredictable results.\",\n        name, method.getDeclaringClass().getName())) : new MethodInvoker(method);\n    //记录属性名与get方法的关系\n    getMethods.put(name, invoker);\n     //解析返回值类型,需要了解mybatis的Type 相关的类\n    Type returnType = TypeParameterResolver.resolveReturnType(method, type);\n    //记录属性名与类的type之间的关系\n    getTypes.put(name, typeToClass(returnType));\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("了解了 Reflector.addGetMethods() 方法三个核心步骤之后 ，下面来看其集体实现：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  /**\n   *步骤1: 获取指定类以及其父类和接口中 定义的方法的功能 随着代码的演变已经被抽到上一层去了，\n   *因为对于\n   *addRecordGetMethods()\n   *addGetMethods()\n   *addSetMethods()\n   *方法 都需要本类以及父类所有的方法参数,所以只需要获取一次即可\n   * @param methods\n   */\n  private void addGetMethods(Method[] methods) {\n    //存储符合规则的get 方法 :参数个数为0、方法名称以get开头名称长度大于3的 或者方法名称以is开头名称长度大于2的\n    //存储结构是 key 是 方法名称 对应方法列表 如 getValue方法   对应 key = value  list(0)= public java.lang.Integer org.apache.ibatis.fanxtest.ReflectorTest.brideTest.Circle.getValue()\n    Map<String, List<Method>> conflictingGetters = new HashMap<>();\n    // JavaBean getter 的方法参数必须是1个 并且  (是以get活is开头,如果get开头方法名称长度大于3,is开头方法名称长度大于2)\n    //步骤2 ：按照 JavaBean 规范查找 getter 法，并记 conflictingGetters 合中\n    Arrays.stream(methods).filter(m -> m.getParameterTypes().length == 0 && PropertyNamer.isGetter(m.getName()))\n        .forEach(m -> addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));\n    //步骤3：对 conflictingGetters 集合进行处理\n    resolveGetterConflicts(conflictingGetters);\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br")])]),s("p",[e._v("Reflector.addFields()方法会处理类中定义的所有字段 并且将处理后的字段信息添加到 setMethods 集合、 setTypes 集合、\ngetMethods 集合以及 getTypes 合中，\nReflector.addGetMethods() 根据类的get方法添加对应的属性,Reflector.addFields()获取所有字段，添加的字段。这块需要注意的是\naddGetMethods() 对应的invoker对应的是 MethodInvoker对象 而addFields() 的invoker对应的是GetFieldInvoker对象")]),e._v(" "),s("p",[e._v("Reflector addFields（）方法 具体实现如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  //将属性名与字段名不相同的字段添加到 getmethods 与setmethods中\n  private void addFields(Class<?> clazz) {\n    //返回的是当前类中声明的所有字段，包括公共、私有和受保护的字段，但不包括继承自父类的字段。返回的字段数组是一个包含 Field 对象的数组\n    Field[] fields = clazz.getDeclaredFields();\n    for (Field field : fields) {\n      if (!setMethods.containsKey(field.getName())) {\n        // issue #379 - removed the check for final because JDK 1.5 allows\n        // modification of final fields through reflection (JSR-133). (JGB)\n        // pr #16 - final static can only be set by the classloader\n        //除了对 final 字段的检查，允许通过反射修改 final 字段的值。\n        //对于 final static 字段，限制只能由类加载器设置，不允许通过反射修改其值。\n        int modifiers = field.getModifiers();\n        if ((!Modifier.isFinal(modifiers) || !Modifier.isStatic(modifiers))) {\n          addSetField(field);\n        }\n      }\n      if (!getMethods.containsKey(field.getName())) {\n        addGetField(field);\n      }\n    }\n    if (clazz.getSuperclass() != null) {\n      addFields(clazz.getSuperclass());\n    }\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br")])]),s("p",[e._v("Reflector 的初始化过程就介绍到这里了。 Reflector 中提供了多个 get＊() 方法用于读取上述集合中记录的元信息，代码比较简单，请读者参考源码。")]),e._v(" "),s("p",[e._v("还有一点需要注意的是， add"),s("em",[e._v("Method()方法和 add")]),e._v("Field()方法在向上述集合添加元素时，\n会将 getter/setter 方法对应的 Method 对象以及字段对应的 Field 对象统一封装成 Invoker 对象。\nInvoker 接口的定义如下所示。")]),e._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[e._v("public interface Invoker "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  Object invoke"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Object target, Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" throws IllegalAccessException, InvocationTargetException"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n  Class"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("?"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" getType"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("Invoker 接口的实现如下图所示\n"),s("img",{attrs:{src:n(3497),alt:"Invoker实现图解.png"}})]),e._v(" "),s("p",[e._v("GetFieldlnvoker/SetFieldlnvoker 通过 field 字段封装了对应的 Field 对象，两者的 invoke()方法是通过调用 Field.get()/set()方法实现的。 Methodlnvoker 通过 method 字段封装了对应方法的 Method 对象，其 invoke()方法是通过调用 Method.invoke()方法实现的 。具体代码比较简单，就 不再贴出来了。")]),e._v(" "),s("p",[e._v("ReflectorFactory 接口主要实现了对 Reflector 对象的创建和缓存，该接口定义如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public interface ReflectorFactory {\n  // 检测该 Ref lectorFactory 对象是否会缓存 Reflector 对象\n  boolean isClassCacheEnabled();\n  //设置是否缓存 Reflector 对象\n  void setClassCacheEnabled(boolean classCacheEnabled);\n  //创建指定 Class 对应的 Reflector 对象\n  Reflector findForClass(Class<?> type);\n}\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("MyBatis 只为该接口提供了 DefaultReflectorFactory 这一个实现类，它与 Reflector 的关系如下图所示\n"),s("img",{attrs:{src:n(3498),alt:"DefaultReflectorFactory"}})]),e._v(" "),s("p",[e._v("DefaultReflectorFactory 类中字段的含义如下:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//该字段决定是否开启对 Reflector 对象的缓存\n  private boolean classCacheEnabled = true;\n  //使用 ConcurrentMap 集合实现对 Reflector 对象的缓存\n  private final ConcurrentMap<Class<?>, Reflector> reflectorMap = new ConcurrentHashMap<>();\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("DefaultReflectorFactory 提供的 findForClass() 方法实现会为指定的 Class 创建 Reflector 对象，\n并将 Reflector 象缓存到 reflectorMap 中， 具体代码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   @Override\n  public Reflector findForClass(Class<?> type) {\n    if (classCacheEnabled) {\n      //如果开启缓存,则查看reflectorMap 是否含有type,不存在则创建 type对象放入reflectorMap中并返回\n      // synchronized (type) removed see issue #461\n      return MapUtil.computeIfAbsent(reflectorMap, type, Reflector::new);\n    }\n    //未开启缓存，则直接创建并返回 Ref lector 对象\n    return new Reflector(type);\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("除了使用 MyBatis 提供的 DefaultReflectorFactory 实现，我们还可以在 mybatis-config.xml\n中配置自定义的 ReflectorFactory 实现类，从而实现功能上的扩展。在后面介绍 MyBatis 初始化 流程时 ，还会提到该扩展点。")]),e._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("configuration"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),e._v("-- 其他配置项 --"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("reflectorFactory "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"com.example.CustomReflectorFactory"')]),e._v(" /"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("/configuration"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h2",{attrs:{id:"typeparameterresolver"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typeparameterresolver"}},[e._v("#")]),e._v(" TypeParameterResolver")]),e._v(" "),s("p",[e._v("在开始介绍 TypeParameterResolver 之前， 先简单介绍 Type 接口的基础知识。 Type是所有类型的父接口,他有四个子接口和一个实现类。如下图所示\n"),s("img",{attrs:{src:n(3499),alt:"Type类结构图"}})]),e._v(" "),s("p",[e._v("下面来看这些子接口和子类所代表的类型。")]),e._v(" "),s("ul",[s("li",[s("p",[e._v('Class 比较常见，它表示的是原始类型。 Class 类的对象表示JVM中的一个类或接口。每个 Java 类在 JVM 里都表现为一个 Class 对象。在程序中可以通过"类名.class"、\n"对象.getClass()"或是"Class.forName("类名")"等方式获取CLass对象。数组也被映射为CLass对象,所有元素类型相同且维数相同的数组都共享同一个Class对象。')])]),e._v(" "),s("li",[s("p",[e._v("ParameterizedType 表示的是参数化类型，例如 List<String>、 Map<Integer,String＞、Service<User＞这种带有泛型的类型。"),s("br"),e._v("\nParameterizedType 接口中常用的方法有三个，分别是：")]),e._v(" "),s("ul",[s("li",[e._v("Type getRawType()一一返回参数化类型中的原始类型，例如 List<String> 的原始类\n型为 List。")]),e._v(" "),s("li",[e._v("Type[] getActualTypeArguments()一一获取参数化类型的类型变量或是实际类型列表，例如 Map<Integer,String> 的实际泛型列表 Integer和String 。\n需要注意的是,该列表的元素类型都是Type,也就是说,可能存在多层嵌套的情况。")]),e._v(" "),s("li",[e._v("Type getOwnerType()一一返回是类型所属的类型，例如存在A<T>类，其中定义了内部类 innerA<I> ，则InnerA<I> 所属的类型为 A<T＞，如果是顶层类型则返回 null。\n这种关系比较常见的示例是 Map<K,V＞接口与 Map.Entry<K,V＞接口 Map<K,V>接口是 Map.Entry<K,V＞接口的所有者。")])])]),e._v(" "),s("li",[s("p",[e._v("TypeVariable 表示的是类型变量，它用来反映在JVM 编译该泛型前的信息。例如 List<T>中的 就是类型变量，它在编译时需被转换为一个具体的类型后才能正常使用。该接口中常用的方法有三个，分别是：")]),e._v(" "),s("ul",[s("li",[e._v("Type[] getBounds()一一获取类型变量的上边界，如果未明确声明上边界则默认为Object 例如 class Test<K extends Person> 的上界就是 Person")]),e._v(" "),s("li",[e._v("D getGenericDeclaration（）一一获取声明该类型变量的原始类型，例如 class Test<K extends Person＞中 的原始类型是 Test")]),e._v(" "),s("li",[e._v("String getName()一一获取在源码中定义时的名字，上例中为K")])])]),e._v(" "),s("li",[s("p",[e._v("GenericArrayType 表示的是数组类型且组成元素是 ParameterizedType或TypeVariable。\n例如 List<String＞[]或T[] 。该接口只有 Type getGenericComponentType() 一个方法，它\n返回数组的组成元素。")])]),e._v(" "),s("li",[s("p",[e._v("WildcardType 表示的是通配符泛型，例如 ? extends Number 和 ? super Integer\nWildcardType 接口有两个方法，分别是:")]),e._v(" "),s("ul",[s("li",[e._v("Type[] getUpperBounds()一一－返回泛型变量的上界。")]),e._v(" "),s("li",[e._v("Type[] getLowerBounds()一－返回泛型变量的下界")])])])]),e._v(" "),s("p",[e._v("   介绍完 Type 接口的基础知识，我们回到对 TypeParameterResolver 介绍。在对 Reflector分析过程中，我们看到了 TypeParameterResolver 的身影，它是一个工具类，提供了一系列静态 方法来解析指定类中的宇段、方法返回值或方法参数的类型。 TypeParameterResolver 中各个静 态方法之间的调用关系大致如下图所示，为保持清晰，其中递归调用没有表现出来，在后面 的代码分析过程中会进行强调。")])])}),[],!1,null,null,null);s.default=t.exports}}]);