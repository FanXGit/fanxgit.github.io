(window.webpackJsonp=window.webpackJsonp||[]).push([[505],{3579:function(a,e,s){"use strict";s.r(e);var t=s(7),r=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"java-8-类型注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-8-类型注解"}},[a._v("#")]),a._v(" Java 8 - 类型注解")]),a._v(" "),e("p",[a._v("===============================")]),a._v(" "),e("blockquote",[e("p",[a._v("理解Java 8 类型注解需理解几个问题: @pdai")]),a._v(" "),e("ul",[e("li",[a._v("注解在JDK哪个版本中出现的，可以在哪些地方用注解?")]),a._v(" "),e("li",[a._v("什么是类型注解?")]),a._v(" "),e("li",[a._v("类型注解的作用是什么?")]),a._v(" "),e("li",[a._v("为什么会出现类型注解(JSR308)?")])])]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#java-8---%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"}},[a._v("Java 8 - 类型注解")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"}},[a._v("什么是类型注解")])]),a._v(" "),e("li",[e("a",{attrs:{href:"#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8"}},[a._v("类型注解的作用")])]),a._v(" "),e("li",[e("a",{attrs:{href:"#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"}},[a._v("类型注解向下兼容的解决方案")])]),a._v(" "),e("li",[e("a",{attrs:{href:"#%E5%85%B3%E4%BA%8Ejsr-308"}},[a._v("关于JSR 308")])]),a._v(" "),e("li",[e("a",{attrs:{href:"#%E6%80%BB%E7%BB%93"}},[a._v("总结")])])])])]),a._v(" "),e("h2",{attrs:{id:"什么是类型注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是类型注解"}},[a._v("#")]),a._v(" 什么是类型注解")]),a._v(" "),e("hr"),a._v(" "),e("blockquote",[e("p",[a._v("注解大家都知道，从java5开始加入这一特性，发展到现在已然是遍地开花，在很多框架中得到了广泛的使用，用来简化程序中的配置。那充满争议的类型注解究竟是什么? 复杂还是便捷?")])]),a._v(" "),e("ol",[e("li",[e("p",[a._v("在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；")])]),a._v(" "),e("li",[e("p",[a._v("java 8里面，注解可以应用在任何地方，比如:")])])]),a._v(" "),e("p",[a._v("创建类实例")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("new @Interned MyObject(); \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("类型映射")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("myString = (@NonNull String) str; \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("implements 语句中")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class UnmodifiableList<T> implements @Readonly List<@Readonly T> { … } \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("throw exception声明")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("void monitorTemperature() throws @Critical TemperatureException { … } \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("需要注意的是，"),e("strong",[a._v("类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解")]),a._v("。")]),a._v(" "),e("h2",{attrs:{id:"类型注解的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型注解的作用"}},[a._v("#")]),a._v(" 类型注解的作用")]),a._v(" "),e("hr"),a._v(" "),e("p",[a._v("先看看下面代码")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('Collections.emptyList().add("One");\nint i=Integer.parseInt("hello");\nSystem.console().readLine(); \n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("上面的代码编译是通过的，但运行是会分别报UnsupportedOperationException； NumberFormatException；NullPointerException异常，这些都是runtime error；")]),a._v(" "),e("p",[a._v("类型注解被用来支持在Java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。")]),a._v(" "),e("p",[a._v("check framework是第三方工具，配合Java的类型注解效果就是1+1>2。它可以嵌入到javac编译器里面，可以配合ant和maven使用, 地址是http://types.cs.washington.edu/checker-framework/。 check framework可以找到类型注解出现的地方并检查，举个简单的例子:")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import checkers.nullness.quals.*;\npublic class GetStarted {\n    void sample() {\n        @NonNull Object ref = new Object();\n    }\n} \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("p",[a._v("使用javac编译上面的类")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("javac -processor checkers.nullness.NullnessChecker GetStarted.java \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("编译是通过，但如果修改成")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@NonNull Object ref = null; \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("再次编译，则出现")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("GetStarted.java:5: incompatible types.\nfound   : @Nullable <nulltype>\nrequired: @NonNull Object\n        @NonNull Object ref = null;\n                              ^\n1 error \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h2",{attrs:{id:"类型注解向下兼容的解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型注解向下兼容的解决方案"}},[a._v("#")]),a._v(" 类型注解向下兼容的解决方案")]),a._v(" "),e("hr"),a._v(" "),e("p",[a._v("如果你不想使用类型注解检测出来错误，则不需要processor，直接javac GetStarted.java是可以编译通过的，这是在java 8 with Type Annotation Support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@NonNull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用/**/注释起来，比如上面例子修改为")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import checkers.nullness.quals.*;\npublic class GetStarted {\n    void sample() {\n        /*@NonNull*/ Object ref = null;\n    }\n} \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("p",[a._v("这样javac编译器就会忽略掉注释块，但用check framework里面的javac编译器同样能够检测出nonnull错误。 通过类型注解+check framework我们可以看到，现在runtime error可以在编译时候就能找到。")]),a._v(" "),e("h2",{attrs:{id:"关于jsr-308"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于jsr-308"}},[a._v("#")]),a._v(" 关于JSR 308")]),a._v(" "),e("hr"),a._v(" "),e("p",[a._v("JSR 308想要解决在Java 1.5注解中出现的两个问题:")]),a._v(" "),e("ul",[e("li",[a._v("在句法上对注解的限制: 只能把注解写在声明的地方")]),a._v(" "),e("li",[a._v("类型系统在语义上的限制: 类型系统还做不到预防所有的bug")])]),a._v(" "),e("p",[a._v("JSR 308 通过如下方法解决上述两个问题:")]),a._v(" "),e("ul",[e("li",[a._v("对Java语言的句法进行扩充，允许注解出现在更多的位置上。包括: 方法接收器(method receivers，译注: 例public int size() @Readonly { … })，泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性")]),a._v(" "),e("li",[a._v("通过引入可插拔的类型系统(pluggable type systems)能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework")])]),a._v(" "),e("p",[a._v("对JSR308，有人反对，觉得更复杂更静态了，比如")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("@NotEmpty List<@NonNull String> strings = new ArrayList<@NonNull String>()> \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("换成动态语言为")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var strings = ["one", "two"]; \n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。")]),a._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("hr"),a._v(" "),e("p",[a._v("并不是人人都喜欢这个特性，特别是动态语言比较流行的今天，所幸，java 8并不强求大家使用这个特性，反对的人可以不使用这一特性，而对代码质量有些要求比较高的人或公司可以采用JSR 308，毕竟代码才是“最基本”的文档，这句话我是赞同的。虽然代码会增多，但可以使你的代码更具有表达意义。对这个特性有何看法，大家各抒己见。。。。")])])}),[],!1,null,null,null);e.default=r.exports}}]);