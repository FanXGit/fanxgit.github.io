(window.webpackJsonp=window.webpackJsonp||[]).push([[575],{3803:function(t,a,r){"use strict";r.r(a);var e=r(7),_=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"大数据处理-双层桶划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大数据处理-双层桶划分"}},[t._v("#")]),t._v(" 大数据处理 - 双层桶划分")]),t._v(" "),a("p",[t._v("===============================")]),t._v(" "),a("blockquote",[a("p",[t._v("本文主要介绍大数据处理之分桶处理。@pdai")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-domain-bigdata-bucket.html#%E5%88%86%E6%A1%B6%E6%B3%95%E7%AE%80%E4%BB%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("分桶法简介"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-domain-bigdata-bucket.html#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE",target:"_blank",rel:"noopener noreferrer"}},[t._v("相关题目"),a("OutboundLink")],1),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-domain-bigdata-bucket.html#_2-5%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E4%BB%A5%E5%AE%B9%E7%BA%B3%E8%BF%992-5%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E3%80%82",target:"_blank",rel:"noopener noreferrer"}},[t._v("2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-domain-bigdata-bucket.html#_5%E4%BA%BF%E4%B8%AAint%E6%89%BE%E5%AE%83%E4%BB%AC%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%82",target:"_blank",rel:"noopener noreferrer"}},[t._v("5亿个int找它们的中位数。"),a("OutboundLink")],1)])])])]),t._v(" "),a("h1",{attrs:{id:"分桶法简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分桶法简介"}},[t._v("#")]),t._v(" 分桶法简介")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("其实本质上还是分而治之的思想，重在“分”的技巧上！")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("适用范围")]),t._v(": 第k大，中位数，不重复或重复的数字")]),t._v(" "),a("li",[a("code",[t._v("基本原理及要点")]),t._v(": 因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。")])]),t._v(" "),a("h1",{attrs:{id:"相关题目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关题目"}},[t._v("#")]),t._v(" 相关题目")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-5亿个整数中找出不重复的整数的个数-内存空间不足以容纳这2-5亿个整数。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5亿个整数中找出不重复的整数的个数-内存空间不足以容纳这2-5亿个整数。"}},[t._v("#")]),t._v(" 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。")]),t._v(" "),a("p",[t._v("有点像鸽巢原理，整数个数为232,也就是，我们可以将这232个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。")]),t._v(" "),a("h3",{attrs:{id:"_5亿个int找它们的中位数。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5亿个int找它们的中位数。"}},[t._v("#")]),t._v(" 5亿个int找它们的中位数。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("思路一")])])]),t._v(" "),a("p",[t._v("这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。")]),t._v(" "),a("p",[t._v("实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成224个区域，然后确定区域的第几大数，在将该区域分成220个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("思路二")])])]),t._v(" "),a("p",[t._v("同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。")]),t._v(" "),a("p",[t._v("方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。")]),t._v(" "),a("p",[t._v("第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该"),a("code",[t._v("<n/2")]),t._v("(2.5亿)。而k+1 - 65535的计数和也"),a("code",[t._v("<n/2")]),t._v("，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。)")])])}),[],!1,null,null,null);a.default=_.exports}}]);