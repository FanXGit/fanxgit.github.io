(window.webpackJsonp=window.webpackJsonp||[]).push([[498],{3531:function(a,t,s){"use strict";s.r(t);var v=s(7),e=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"线程池大小设置多少-比较合适"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池大小设置多少-比较合适"}},[a._v("#")]),a._v(" 线程池大小设置多少，比较合适？")]),a._v(" "),t("h3",{attrs:{id:"对于cpu密集型的计算机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对于cpu密集型的计算机"}},[a._v("#")]),a._v(" 对于cpu密集型的计算机")]),a._v(" "),t("p",[a._v("对于 CPU 密集型任务，我们希望最大限度地提高 CPU 利用率，但又不会因为过多的线程而压垮系统，否则会导致过多的上下文切换。一个常见的经验法则是使用可用的 CPU 核心数量")]),a._v(" "),t("p",[a._v("计算可用 CPU 核心数：在 Java 中用于Runtime.getRuntime().availableProcessors()确定可用 CPU 核心的数量。假设我们有 8 个核心。")]),a._v(" "),t("p",[a._v("创建线程池： 创建大小接近或略小于可用CPU核心数的线程池。在这种情况下，我们可以选择 6 或 7 个线程，为其他任务和系统进程留下一些 CPU 容量。")]),a._v(" "),t("h3",{attrs:{id:"对于-i-o-密集型任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对于-i-o-密集型任务"}},[a._v("#")]),a._v(" 对于 I/O 密集型任务")]),a._v(" "),t("p",[a._v("对于 I/O 密集型任务，最佳线程数通常由 I/O 操作的性质和预期延迟决定。我们希望有足够的线程来保持 I/O 设备繁忙而不会使它们过载。"),t("strong",[a._v("理想的数量不一定等于CPU核心的数量")]),a._v("。")]),a._v(" "),t("p",[a._v("线程数 = 可用核心数 * 目标 CPU 利用率 * (1 + 等待时间 / 服务时间)")]),a._v(" "),t("ul",[t("li",[a._v("可用核心数： 这是我们的应用程序可用的CPU 核心数。需要注意的是，这与 CPU 的数量不同，因为每个 CPU 可能有多个核心。")]),a._v(" "),t("li",[a._v("目标 CPU 利用率： 这是我们希望应用程序使用的CPU 时间的百分比。如果我们将目标 CPU 利用率设置得太高，我们的应用程序可能会变得无响应。如果设置得太低，我们的应用程序将无法充分利用可用的 CPU 资源。")]),a._v(" "),t("li",[a._v("等待时间： 这是线程等待 I/O 操作完成所花费的时间。这可能包括等待网络响应、数据库查询或文件操作。")]),a._v(" "),t("li",[a._v("服务时间： 这是线程执行计算所花费的时间量。")]),a._v(" "),t("li",[a._v("阻塞系数： 这是等待时间与服务时间的比率。它衡量线程等待 I/O 操作完成所花费的时间相对于执行计算所花费的时间。")])]),a._v(" "),t("h3",{attrs:{id:"用法示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用法示例"}},[a._v("#")]),a._v(" 用法示例")]),a._v(" "),t("p",[a._v("假设我们有一台具有 4 个 CPU 核心的服务器，并且我们希望应用程序使用 50% 的可用 CPU 资源。")]),a._v(" "),t("p",[a._v("我们的应用程序有两类任务：I/O 密集型任务和 CPU 密集型任务。")]),a._v(" "),t("p",[a._v("I/O 密集型任务的阻塞系数为 0.5，这意味着它们花费 50% 的时间等待 I/O 操作完成。")]),a._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("线程数 = 4 核 * 0.5 * (1 + 0.5) = 3 线程\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("CPU 密集型任务的阻塞系数为 0.1，这意味着它们花费 10% 的时间等待 I/O 操作完成。")]),a._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("线程数 = 4 核 * 0.5 * (1 + 0.1) = 2.2 线程\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("在此示例中，我们将创建两个线程池，一个用于 I/O 密集型任务，另一个用于 CPU 密集型任务。I/O 密集型线程池将有 3 个线程，CPU 密集型线程池将有 2 个线程。")]),a._v(" "),t("p",[a._v("这是根据大量的案例总结的Java线程池大小确定的公式，但在实操中所考虑的侧重点可能有不同，那么需要根据实际场景来微调，本文提供一种确定最优的思路，希望对你开发中确定线程池大小有所帮助！")])])}),[],!1,null,null,null);t.default=e.exports}}]);