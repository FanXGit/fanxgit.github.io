(window.webpackJsonp=window.webpackJsonp||[]).push([[375],{3038:function(n,e){n.exports="data:image/png;base64,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"},3039:function(n,e,a){n.exports=a.p+"assets/img/2_singleton_1.f3ca1f7e.png"},4044:function(n,e,a){"use strict";a.r(e);var s=a(7),t=Object(s.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"创建型-单例模式-singleton-pattern"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建型-单例模式-singleton-pattern"}},[n._v("#")]),n._v(" 创建型 - 单例模式(Singleton pattern)")]),n._v(" "),e("p",[n._v("==============================================================")]),n._v(" "),e("blockquote",[e("p",[n._v("本文主要分析单例模式(Singleton pattern): 确保一个类只有一个实例，并提供该实例的全局访问点, 本文介绍6中常用的实现方式。@pdai")])]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%e5%88%9b%e5%bb%ba%e5%9e%8b---%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8fsingleton-pattern"}},[n._v("创建型 - 单例模式(Singleton pattern)")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%e7%b1%bb%e5%9b%be"}},[n._v("类图")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#6%e4%b8%ad%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f"}},[n._v("6中实现方式")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e6%80%bb%e7%bb%93"}},[n._v("实现方式总结")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e6%87%92%e6%b1%89%e5%bc%8f-%e7%ba%bf%e7%a8%8b%e4%b8%8d%e5%ae%89%e5%85%a8"}},[n._v("懒汉式-线程不安全")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e9%a5%bf%e6%b1%89%e5%bc%8f-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8"}},[n._v("饿汉式-线程安全")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e6%87%92%e6%b1%89%e5%bc%8f-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8"}},[n._v("懒汉式-线程安全")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e5%8f%8c%e9%87%8d%e6%a0%a1%e9%aa%8c%e9%94%81-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8"}},[n._v("双重校验锁-线程安全")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e9%9d%99%e6%80%81%e5%86%85%e9%83%a8%e7%b1%bb%e5%ae%9e%e7%8e%b0"}},[n._v("静态内部类实现")])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e6%9e%9a%e4%b8%be%e5%ae%9e%e7%8e%b0"}},[n._v("枚举实现")])])])]),n._v(" "),e("li",[e("a",{attrs:{href:"#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af"}},[n._v("使用场景")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#jdk"}},[n._v("JDK")])])])])])])]),n._v(" "),e("h1",{attrs:{id:"类图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[n._v("#")]),n._v(" 类图")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。")]),n._v(" "),e("p",[n._v("私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。")]),n._v(" "),e("p",[e("img",{attrs:{src:a(3038),alt:""}})]),n._v(" "),e("h1",{attrs:{id:"_6中实现方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6中实现方式"}},[n._v("#")]),n._v(" 6中实现方式")]),n._v(" "),e("hr"),n._v(" "),e("h3",{attrs:{id:"实现方式总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现方式总结"}},[n._v("#")]),n._v(" 实现方式总结")]),n._v(" "),e("p",[e("img",{attrs:{src:a(3039),alt:""}})]),n._v(" "),e("h3",{attrs:{id:"懒汉式-线程不安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#懒汉式-线程不安全"}},[n._v("#")]),n._v(" 懒汉式-线程不安全")]),n._v(" "),e("p",[n._v("以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。")]),n._v(" "),e("p",[n._v("这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 "),e("code",[n._v("if (uniqueInstance == null)")]),n._v(" ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 "),e("code",[n._v("uniqueInstance = new Singleton();")]),n._v(" 语句，这将导致多次实例化 uniqueInstance。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public class Singleton {\n\n    private static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getUniqueInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br")])]),e("h3",{attrs:{id:"饿汉式-线程安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#饿汉式-线程安全"}},[n._v("#")]),n._v(" 饿汉式-线程安全")]),n._v(" "),e("p",[n._v("线程不安全问题主要是由于 uniqueInstance 被多次实例化，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。")]),n._v(" "),e("p",[n._v("但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("private static Singleton uniqueInstance = new Singleton();\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("h3",{attrs:{id:"懒汉式-线程安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#懒汉式-线程安全"}},[n._v("#")]),n._v(" 懒汉式-线程安全")]),n._v(" "),e("p",[n._v("只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了多次实例化 uniqueInstance 的问题。")]),n._v(" "),e("p",[n._v("但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，因此性能上有一定的损耗。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public static synchronized Singleton getUniqueInstance() {\n    if (uniqueInstance == null) {\n        uniqueInstance = new Singleton();\n    }\n    return uniqueInstance;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("h3",{attrs:{id:"双重校验锁-线程安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双重校验锁-线程安全"}},[n._v("#")]),n._v(" 双重校验锁-线程安全")]),n._v(" "),e("p",[n._v("uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。")]),n._v(" "),e("p",[n._v("双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getUniqueInstance() {\n        if (uniqueInstance == null) {\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br")])]),e("p",[n._v("考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程同时执行 if 语句，那么两个线程就会同时进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 "),e("code",[n._v("uniqueInstance = new Singleton();")]),n._v(" 这条语句，只是先后的问题，那么就会进行两次实例化，从而产生了两个实例。因此必须使用双重校验锁，也就是需要使用两个 if 语句。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (uniqueInstance == null) {\n    synchronized (Singleton.class) {\n        uniqueInstance = new Singleton();\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("p",[n._v("uniqueInstance 采用 volatile 关键字修饰也是很有必要的。"),e("code",[n._v("uniqueInstance = new Singleton();")]),n._v(" 这段代码其实是分为三步执行。")]),n._v(" "),e("ol",[e("li",[n._v("分配内存空间")]),n._v(" "),e("li",[n._v("初始化对象")]),n._v(" "),e("li",[n._v("将 uniqueInstance 指向分配的内存地址")])]),n._v(" "),e("p",[n._v("但是由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1>3>2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以致于程序出错。")]),n._v(" "),e("p",[n._v("使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。")]),n._v(" "),e("h3",{attrs:{id:"静态内部类实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态内部类实现"}},[n._v("#")]),n._v(" 静态内部类实现")]),n._v(" "),e("p",[n._v("当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 "),e("code",[n._v("getUniqueInstance()")]),n._v(" 方法从而触发 "),e("code",[n._v("SingletonHolder.INSTANCE")]),n._v(" 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。")]),n._v(" "),e("p",[n._v("这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public class Singleton {\n\n    private Singleton() {\n    }\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    public static Singleton getUniqueInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br")])]),e("h3",{attrs:{id:"枚举实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#枚举实现"}},[n._v("#")]),n._v(" 枚举实现")]),n._v(" "),e("p",[n._v("这是单例模式的最佳实践，它实现简单，并且在面对复杂的序列化或者反射攻击的时候，能够防止实例化多次。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public enum Singleton {\n    uniqueInstance;\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br")])]),e("p",[n._v("考虑以下单例模式的实现，该 Singleton 在每次序列化的时候都会创建一个新的实例，为了保证只创建一个实例，必须声明所有字段都是 transient，并且提供一个 readResolve() 方法。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public class Singleton implements Serializable {\n\n    private static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static synchronized Singleton getUniqueInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br")])]),e("p",[n._v("如果不使用枚举来实现单例模式，会出现反射攻击，因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化第二个对象的代码。")]),n._v(" "),e("p",[n._v("从上面的讨论可以看出，解决序列化和反射攻击很麻烦，而枚举实现不会出现这两种问题，所以说枚举实现单例模式是最佳实践。")]),n._v(" "),e("h1",{attrs:{id:"使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[n._v("#")]),n._v(" 使用场景")]),n._v(" "),e("hr"),n._v(" "),e("ul",[e("li",[n._v("Logger Classes")]),n._v(" "),e("li",[n._v("Configuration Classes")]),n._v(" "),e("li",[n._v("Accesing resources in shared mode")]),n._v(" "),e("li",[n._v("Factories implemented as Singletons")])]),n._v(" "),e("h3",{attrs:{id:"jdk"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jdk"}},[n._v("#")]),n._v(" JDK")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29",target:"_blank",rel:"noopener noreferrer"}},[n._v("java.lang.Runtime#getRuntime() 在新窗口打开"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--",target:"_blank",rel:"noopener noreferrer"}},[n._v("java.awt.Desktop#getDesktop() 在新窗口打开"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--",target:"_blank",rel:"noopener noreferrer"}},[n._v("java.lang.System#getSecurityManager() 在新窗口打开"),e("OutboundLink")],1),n._v(")")])])])}),[],!1,null,null,null);e.default=t.exports}}]);