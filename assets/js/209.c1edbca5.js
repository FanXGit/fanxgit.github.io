(window.webpackJsonp=window.webpackJsonp||[]).push([[209],{3519:function(e,s,n){"use strict";n.r(s);var a=n(7),t=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"collection-priorityqueue源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#collection-priorityqueue源码解析"}},[e._v("#")]),e._v(" Collection - PriorityQueue源码解析")]),e._v(" "),s("p",[e._v("=================================================================")]),e._v(" "),s("blockquote",[s("p",[e._v("本文主要对Collection - PriorityQueue进行源码解析。@pdai")])]),e._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("前面以Java "),s("em",[e._v("ArrayDeque_为例讲解了_Stack_和_Queue")]),e._v("，其实还有一种特殊的队列叫做_PriorityQueue_，即优先队列。"),s("strong",[e._v("优先队列的作用是能保证每次取出的元素都是队列中权值最小的")]),e._v("(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，"),s("strong",[e._v("元素大小的评判可以通过元素本身的自然顺序("),s("em",[e._v("natural ordering")]),e._v(")，也可以通过构造时传入的比较器")]),e._v("("),s("em",[e._v("Comparator")]),e._v("，类似于C++的仿函数)。")]),e._v(" "),s("p",[e._v("Java中_PriorityQueue_实现了_Queue_接口，不允许放入"),s("code",[e._v("null")]),e._v("元素；其通过堆实现，具体说是通过完全二叉树("),s("em",[e._v("complete binary tree")]),e._v(")实现的"),s("strong",[e._v("小顶堆")]),e._v("(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为_PriorityQueue_的底层实现。")]),e._v(" "),s("p",[s("img",{attrs:{src:n(409),alt:"PriorityQueue_base.png"}})]),e._v(" "),s("p",[e._v("上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:")]),e._v(" "),s("p",[s("code",[e._v("leftNo = parentNo*2+1")])]),e._v(" "),s("p",[s("code",[e._v("rightNo = parentNo*2+2")])]),e._v(" "),s("p",[s("code",[e._v("parentNo = (nodeNo-1)/2")])]),e._v(" "),s("p",[e._v("通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。")]),e._v(" "),s("p",[s("em",[e._v("PriorityQueue_的"),s("code",[e._v("peek()")]),e._v("和"),s("code",[e._v("element")]),e._v("操作是常数时间，"),s("code",[e._v("add()")]),e._v(", "),s("code",[e._v("offer()")]),e._v(", 无参数的"),s("code",[e._v("remove()")]),e._v("以及"),s("code",[e._v("poll()")]),e._v("方法的时间复杂度都是_log(N)")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"方法剖析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法剖析"}},[e._v("#")]),e._v(" 方法剖析")]),e._v(" "),s("hr"),e._v(" "),s("h3",{attrs:{id:"add-和offer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#add-和offer"}},[e._v("#")]),e._v(" add()和offer()")]),e._v(" "),s("p",[s("code",[e._v("add(E e)")]),e._v("和"),s("code",[e._v("offer(E e)")]),e._v("的语义相同，都是向优先队列中插入元素，只是"),s("code",[e._v("Queue")]),e._v("接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回"),s("code",[e._v("false")]),e._v("。对于_PriorityQueue_这两个方法其实没什么差别。")]),e._v(" "),s("p",[s("img",{attrs:{src:n(410),alt:"PriorityQueue_offer.png"}})]),e._v(" "),s("p",[e._v("新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//offer(E e)\npublic boolean offer(E e) {\n    if (e == null)//不允许放入null元素\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        grow(i + 1);//自动扩容\n    size = i + 1;\n    if (i == 0)//队列原来为空，这是插入的第一个元素\n        queue[0] = e;\n    else\n        siftUp(i, e);//调整\n    return true;\n} \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("上述代码中，扩容函数"),s("code",[e._v("grow()")]),e._v("类似于"),s("code",[e._v("ArrayList")]),e._v("里的"),s("code",[e._v("grow()")]),e._v("函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是"),s("code",[e._v("siftUp(int k, E x)")]),e._v("方法，该方法用于插入元素"),s("code",[e._v("x")]),e._v("并维持堆的特性。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//siftUp()\nprivate void siftUp(int k, E x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;//parentNo = (nodeNo-1)/2\n        Object e = queue[parent];\n        if (comparator.compare(x, (E) e) >= 0)//调用比较器的比较方法\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n} \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br")])]),s("p",[e._v("新加入的元素"),s("code",[e._v("x")]),e._v("可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为** : 从"),s("code",[e._v("k")]),e._v("指定的位置开始，将"),s("code",[e._v("x")]),e._v("逐层与当前点的"),s("code",[e._v("parent")]),e._v("进行比较并交换，直到满足"),s("code",[e._v("x >= queue[parent]")]),e._v("为止**。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。")]),e._v(" "),s("h3",{attrs:{id:"element-和peek"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#element-和peek"}},[e._v("#")]),e._v(" element()和peek()")]),e._v(" "),s("p",[s("code",[e._v("element()")]),e._v("和"),s("code",[e._v("peek()")]),e._v("的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回"),s("code",[e._v("null")]),e._v("。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，"),s("code",[e._v("0")]),e._v("下标处的那个元素既是堆顶元素。所以"),s("strong",[e._v("直接返回数组"),s("code",[e._v("0")]),e._v("下标处的那个元素即可")]),e._v("。")]),e._v(" "),s("p",[s("img",{attrs:{src:n(411),alt:"PriorityQueue_peek.png"}})]),e._v(" "),s("p",[e._v("代码也就非常简洁:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//peek()\npublic E peek() {\n    if (size == 0)\n        return null;\n    return (E) queue[0];//0下标处的那个元素就是最小的那个\n} \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("h3",{attrs:{id:"remove-和poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remove-和poll"}},[e._v("#")]),e._v(" remove()和poll()")]),e._v(" "),s("p",[s("code",[e._v("remove()")]),e._v("和"),s("code",[e._v("poll()")]),e._v("方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回"),s("code",[e._v("null")]),e._v("。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。")]),e._v(" "),s("p",[s("img",{attrs:{src:n(412),alt:"PriorityQueue_poll.png"}}),e._v(" 代码如下:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];//0下标处的那个元素就是最小的那个\n    E x = (E) queue[s];\n    queue[s] = null;\n    if (s != 0)\n        siftDown(0, x);//调整\n    return result;\n} \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br")])]),s("p",[e._v("上述代码首先记录"),s("code",[e._v("0")]),e._v("下标处的元素，并用最后一个元素替换"),s("code",[e._v("0")]),e._v("下标位置的元素，之后调用"),s("code",[e._v("siftDown()")]),e._v("方法对堆进行调整，最后返回原来"),s("code",[e._v("0")]),e._v("下标处的那个元素(也就是最小的那个元素)。重点是"),s("code",[e._v("siftDown(int k, E x)")]),e._v("方法，该方法的作用是"),s("strong",[e._v("从"),s("code",[e._v("k")]),e._v("指定的位置开始，将"),s("code",[e._v("x")]),e._v("逐层向下与当前点的左右孩子中较小的那个交换，直到"),s("code",[e._v("x")]),e._v("小于或等于左右孩子中的任何一个为止")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//siftDown()\nprivate void siftDown(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n    \t//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标\n        int child = (k << 1) + 1;//leftNo = parentNo*2+1\n        Object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;//然后用c取代原来的值\n        k = child;\n    }\n    queue[k] = x;\n} \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("h3",{attrs:{id:"remove-object-o"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remove-object-o"}},[e._v("#")]),e._v(" remove(Object o)")]),e._v(" "),s("p",[s("code",[e._v("remove(Object o)")]),e._v("方法用于删除队列中跟"),s("code",[e._v("o")]),e._v("相等的某一个元素(如果有多个相等，只删除一个)，该方法不是_Queue_接口内的方法，而是_Collection_接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，"),s("code",[e._v("remove(Object o)")]),e._v("可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次"),s("code",[e._v("siftDown()")]),e._v("即可。此处不再赘述。")]),e._v(" "),s("p",[s("img",{attrs:{src:n(413),alt:"PriorityQueue_remove2.png"}})]),e._v(" "),s("p",[e._v("具体代码如下:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//remove(Object o)\npublic boolean remove(Object o) {\n\t//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标\n    int i = indexOf(o);\n    if (i == -1)\n        return false;\n    int s = --size;\n    if (s == i) //情况1\n        queue[i] = null;\n    else {\n        E moved = (E) queue[s];\n        queue[s] = null;\n        siftDown(i, moved);//情况2\n        ......\n    }\n    return true;\n} \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),s("ul",[s("li",[e._v("深入理解Java PriorityQueue 结合源码对PriorityQueue进行讲解 http://www.cnblogs.com/CarpenterLee/p/5488070.html")])])])}),[],!1,null,null,null);s.default=t.exports},409:function(e,s,n){e.exports=n.p+"assets/img/collection_PriorityQueue_base.d9dc3ea8.png"},410:function(e,s,n){e.exports=n.p+"assets/img/collection_PriorityQueue_offer.13c08138.png"},411:function(e,s,n){e.exports=n.p+"assets/img/collection_PriorityQueue_peek.9776bc43.png"},412:function(e,s,n){e.exports=n.p+"assets/img/collection_PriorityQueue_poll.a3825d5a.png"},413:function(e,s,n){e.exports=n.p+"assets/img/collection_PriorityQueue_remove2.09cc0ea0.png"}}]);